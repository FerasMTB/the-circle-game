"use client";

import { useEffect, useMemo, useRef, useState } from "react";

type Point = { x: number; y: number };

// Compute circle score and geometry given a set of stroke points.
function computeCircleScore(points: Point[]) {
  if (!points || points.length < 12) {
    return { score: 0, center: { x: 0, y: 0 }, radius: 0, error: 1 };
  }

  // Estimate center as centroid
  let sumX = 0;
  let sumY = 0;
  for (const p of points) {
    sumX += p.x;
    sumY += p.y;
  }
  const cx = sumX / points.length;
  const cy = sumY / points.length;

  // Distances and average radius
  const dists = new Array(points.length);
  let sumR = 0;
  for (let i = 0; i < points.length; i++) {
    const dx = points[i].x - cx;
    const dy = points[i].y - cy;
    const d = Math.hypot(dx, dy);
    dists[i] = d;
    sumR += d;
  }
  const r = sumR / points.length;
  if (r <= 1e-3 || !isFinite(r)) {
    return { score: 0, center: { x: cx, y: cy }, radius: r, error: 1 };
  }

  // Error metric: average absolute radial deviation normalized by radius
  let errSum = 0;
  for (let i = 0; i < dists.length; i++) {
    errSum += Math.abs(dists[i] - r);
  }
  const error = errSum / dists.length / r;

  // Score in [0, 100]
  let score = Math.max(0, 100 * (1 - error));
  if (!isFinite(score)) score = 0;
  const scoreInt = Math.max(0, Math.min(100, Math.round(score)));
  return { score: scoreInt, center: { x: cx, y: cy }, radius: r, error };
}

// Choose a pleasant color based on score buckets
function getColorByScore(score: number) {
  type RGB = { r: number; g: number; b: number };
  const colors: { min: number; rgb: RGB; hex: string }[] = [
    { min: 95, rgb: { r: 16, g: 185, b: 129 }, hex: "#10b981" }, // emerald-500
    { min: 80, rgb: { r: 59, g: 130, b: 246 }, hex: "#3b82f6" }, // blue-500
    { min: 60, rgb: { r: 245, g: 158, b: 11 }, hex: "#f59e0b" }, // amber-500
    { min: 0, rgb: { r: 239, g: 68, b: 68 }, hex: "#ef4444" }, // red-500
  ];
  const chosen = colors.find((c) => score >= c.min) ?? colors[colors.length - 1];
  return {
    hex: chosen.hex,
    rgba: (a: number) => `rgba(${chosen.rgb.r}, ${chosen.rgb.g}, ${chosen.rgb.b}, ${a})`,
  };
}

function BackgroundDeco() {
  return (
    <div aria-hidden className="pointer-events-none absolute inset-0 -z-10 overflow-hidden">
      <div className="absolute -left-24 -top-24 h-80 w-80 rounded-full bg-gradient-to-tr from-fuchsia-400 to-rose-400 opacity-40 blur-3xl animate-blob" />
      <div className="absolute -right-16 top-1/4 h-80 w-80 rounded-full bg-gradient-to-tr from-sky-400 to-indigo-400 opacity-40 blur-3xl animate-blob animation-delay-2000" />
      <div className="absolute left-1/3 bottom-0 h-96 w-96 rounded-full bg-gradient-to-tr from-emerald-400 to-teal-400 opacity-40 blur-3xl animate-blob animation-delay-4000" />
    </div>
  );
}

export default function Home() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null);
  const pointsRef = useRef<Point[]>([]);
  const drawingRef = useRef(false);
  const rafRef = useRef<number | null>(null);
  const [score, setScore] = useState<number | null>(null);
  const [liveScore, setLiveScore] = useState<number | null>(null);
  const [won, setWon] = useState(false);
  const [flash, setFlash] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const lastLiveUpdateRef = useRef(0);

  // Memoize line style to avoid re-allocations
  const lineStyle = useMemo(
    () => ({
      width: 5,
      color: "#111827", // zinc-900
      shadowColor: "rgba(0,0,0,0.06)",
    }),
    []
  );

  // Resize and prepare the canvas for high-DPI rendering.
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctxRef.current = ctx;

    const resize = () => {
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(1, Math.floor(rect.width));
      const height = Math.max(1, Math.floor(rect.height));

      // Set the internal pixel buffer to account for DPR
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      // Reset transform then scale so drawing uses CSS pixels
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      // Clear on resize
      ctx.clearRect(0, 0, width, height);
      // Style
      ctx.lineWidth = lineStyle.width;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = lineStyle.color;
      ctx.shadowColor = lineStyle.shadowColor;
      ctx.shadowBlur = 0;

      // Reset drawing state
      pointsRef.current = [];
      drawingRef.current = false;
    };

    resize();

    // Observe container size changes for responsive canvas
    const ro = new ResizeObserver(() => resize());
    if (containerRef.current) ro.observe(containerRef.current);
    window.addEventListener("resize", resize);
    return () => {
      window.removeEventListener("resize", resize);
      ro.disconnect();
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [lineStyle]);

  // Win flash animation toggle
  useEffect(() => {
    if (won) {
      setFlash(true);
      const t = setTimeout(() => setFlash(false), 900);
      return () => clearTimeout(t);
    }
  }, [won]);

  // Render the current stroke and overlay, computing score live
  const render = () => {
    const canvas = canvasRef.current;
    const ctx = ctxRef.current;
    if (!canvas || !ctx) return;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    ctx.clearRect(0, 0, w, h);

    // premium white canvas background
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    const pts = pointsRef.current;
    let res: { score: number; center: Point; radius: number } | null = null;
    if (pts.length >= 8) {
      const r = computeCircleScore(pts);
      res = { score: r.score, center: r.center, radius: r.radius };
      const now = performance.now();
      if (now - lastLiveUpdateRef.current > 50) {
        lastLiveUpdateRef.current = now;
        setLiveScore(r.score);
      }
    }

    if (pts.length > 0) {
      // Build smooth path
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 0; i < pts.length - 1; i++) {
        const p0 = pts[i];
        const p1 = pts[i + 1];
        const mx = (p0.x + p1.x) / 2;
        const my = (p0.y + p1.y) / 2;
        ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
      }
      ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);

      const s = res?.score ?? liveScore ?? score ?? 0;
      const color = getColorByScore(s);

      // Glow pass
      ctx.save();
      ctx.lineWidth = lineStyle.width + 6;
      ctx.strokeStyle = color.rgba(0.75);
      ctx.shadowColor = color.rgba(0.9);
      ctx.shadowBlur = 18;
      ctx.stroke();
      ctx.restore();

      // Core pass
      ctx.lineWidth = lineStyle.width;
      ctx.shadowBlur = 0;
      ctx.strokeStyle = won ? "#065f46" : "#111827";
      ctx.stroke();
      ctx.restore();
    }

    if (res) {
      const { center, radius, score: s } = res;
      const color = getColorByScore(s);
      ctx.save();
      ctx.setLineDash([6, 10]);
      ctx.lineDashOffset = 0;
      ctx.lineWidth = 2;
      ctx.strokeStyle = color.hex;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      // Center dot
      ctx.globalAlpha = 1;
      ctx.fillStyle = color.hex;
      ctx.beginPath();
      ctx.arc(center.x, center.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  };

  const requestDraw = () => {
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
    rafRef.current = requestAnimationFrame(() => render());
  };

  // Map a pointer event to canvas-local CSS pixel coordinates.
  const eventToPoint = (e: React.PointerEvent<HTMLCanvasElement>): Point => {
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  };

  const onPointerDown = (e: React.PointerEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    canvas.setPointerCapture(e.pointerId);
    drawingRef.current = true;
    setIsDrawing(true);
    pointsRef.current = [eventToPoint(e)];
    setWon(false);
    setScore(null);
    setLiveScore(null);
    requestDraw();
  };

  const onPointerMove = (e: React.PointerEvent<HTMLCanvasElement>) => {
    if (!drawingRef.current) return;

    // Prefer coalesced events for smoothness where supported
    const anyEvent = e as any;
    const coalesced: PointerEvent[] | undefined = anyEvent.getCoalescedEvents?.();
    if (coalesced && coalesced.length > 0) {
      const canvas = canvasRef.current!;
      const rect = canvas.getBoundingClientRect();
      for (const ce of coalesced) {
        pointsRef.current.push({ x: ce.clientX - rect.left, y: ce.clientY - rect.top });
      }
    } else {
      pointsRef.current.push(eventToPoint(e));
    }
    requestDraw();
  };

  const finishStroke = () => {
    drawingRef.current = false;
    setIsDrawing(false);
    const result = computeCircleScore(pointsRef.current);
    setScore(result.score);
    setLiveScore(result.score);
    setWon(result.score >= 95);
    requestDraw();
  };

  const onPointerUp = () => {
    if (!drawingRef.current) return;
    finishStroke();
  };

  const onPointerLeave = () => {
    if (!drawingRef.current) return;
    finishStroke();
  };

  const clearAll = () => {
    pointsRef.current = [];
    setScore(null);
    setLiveScore(null);
    setWon(false);
    requestDraw();
  };

  const activeScore = liveScore ?? score;
  const statusText = useMemo(() => {
    if (activeScore == null) return "Draw a circle in one smooth stroke.";
    if (activeScore >= 95) return `Legend! ${activeScore}% perfect circle ðŸŽ‰`;
    return `Your circle score: ${activeScore}%. ${isDrawing ? "Keep goingâ€¦" : "Try again!"}`;
  }, [activeScore, isDrawing]);
  const ringPercent = Math.max(0, Math.min(100, activeScore ?? 0));
  const ringColor = getColorByScore(activeScore ?? 0).hex;

  return (
    <div className="relative min-h-screen overflow-hidden text-zinc-900">
      <BackgroundDeco />
      <div className="relative mx-auto flex max-w-3xl flex-col items-center px-6 py-14 sm:px-8">
        <header className="mb-8 text-center">
          <h1 className="bg-gradient-to-r from-fuchsia-600 via-sky-500 to-emerald-500 bg-clip-text text-5xl font-extrabold tracking-tight text-transparent sm:text-6xl animate-gradient">
            Circle Master
          </h1>
          <p className="mt-3 text-lg text-zinc-700 sm:text-xl">
            Draw the most perfect circle you can with one stroke.
          </p>
          <div className="mt-4 flex flex-wrap justify-center gap-2">
            <span className="rounded-full bg-fuchsia-500/10 px-3 py-1 text-sm font-medium text-fuchsia-700 ring-1 ring-fuchsia-500/20">One stroke</span>
            <span className="rounded-full bg-sky-500/10 px-3 py-1 text-sm font-medium text-sky-700 ring-1 ring-sky-500/20">Go smooth</span>
            <span className="rounded-full bg-emerald-500/10 px-3 py-1 text-sm font-medium text-emerald-700 ring-1 ring-emerald-500/20">Aim for 95%+</span>
          </div>
        </header>

        <div
          ref={containerRef}
          className={[
            "w-full max-w-xl",
            "rounded-3xl bg-white p-3 shadow-lg ring-1 ring-black/5",
            "transition-shadow",
            won && flash ? "shadow-emerald-300/60 ring-emerald-400" : "",
          ].join(" ")}
        >
          <div className="relative">
            <div
              aria-hidden
              className="pointer-events-none absolute inset-0 rounded-2xl"
              style={{
                background:
                  activeScore != null
                    ? `conic-gradient(${ringColor} ${ringPercent}%, #e5e7eb ${ringPercent}%)`
                    : undefined,
                WebkitMask:
                  "radial-gradient(farthest-side, transparent calc(100% - 10px), #000 0)",
                mask: "radial-gradient(farthest-side, transparent calc(100% - 10px), #000 0)",
                opacity: activeScore != null ? 1 : 0,
                transition: "opacity 200ms ease",
              }}
            />
            <canvas
              ref={canvasRef}
              className="block h-auto w-full touch-none select-none rounded-2xl bg-white outline-none aspect-square"
              style={{ touchAction: "none" }}
              onPointerDown={onPointerDown}
              onPointerMove={onPointerMove}
              onPointerUp={onPointerUp}
              onPointerCancel={onPointerUp}
              onPointerLeave={onPointerLeave}
            />
            {/* Floating live score badge */}
            <div
              className={[
                "pointer-events-none absolute left-4 top-4 select-none rounded-full px-3 py-1 text-sm font-medium shadow-sm",
                activeScore != null ? "opacity-100" : "opacity-0",
                "transition-opacity",
              ].join(" ")}
              style={{
                background:
                  activeScore != null
                    ? `linear-gradient(135deg, ${getColorByScore(activeScore).hex}33, #ffffffcc)`
                    : undefined,
                backdropFilter: "blur(6px)",
                border: "1px solid rgba(0,0,0,0.06)",
              }}
            >
              {activeScore != null ? `${activeScore}%` : ""}
            </div>
          </div>
        </div>

        <div className="mt-8 flex w-full max-w-xl flex-col items-center gap-4">
          <div
            className={[
              "text-center text-lg",
              activeScore != null && activeScore >= 95 ? "text-emerald-600" : "text-zinc-700",
            ].join(" ")}
          >
            {statusText}
          </div>
          <button
            onClick={clearAll}
            className="inline-flex items-center justify-center rounded-full bg-gradient-to-r from-fuchsia-500 to-sky-500 px-5 py-3 text-sm font-semibold text-white shadow-sm transition hover:from-fuchsia-600 hover:to-sky-600 active:translate-y-px"
          >
            Clear / Try Again
          </button>
        </div>
      </div>
    </div>
  );
}

